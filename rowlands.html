<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rowlands Nilpotent Dirac Balance: Local ↔ Nonlocal + Rewrite Emergence</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#101a33;
      --ink:#e9eefc;
      --muted:#a9b6dd;
      --accent:#7aa7ff;
    }
    html,body{height:100%; margin:0; background:radial-gradient(1200px 800px at 20% 10%, #13204a 0%, var(--bg) 55%); color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    .wrap{max-width:1180px; margin:0 auto; padding:18px 14px 24px;}
    h1{font-size:18px; margin:0 0 10px; font-weight:700; letter-spacing:.2px;}
    .sub{color:var(--muted); margin:0 0 14px; line-height:1.35; font-size:13px;}
    .grid{display:grid; grid-template-columns: 1.25fr .75fr; gap:12px;}
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      overflow:hidden;
    }
    .hd{padding:10px 12px; border-bottom:1px solid rgba(255,255,255,.10); display:flex; align-items:center; justify-content:space-between; gap:10px; background:rgba(0,0,0,.15);}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .tag{font-size:12px; color:var(--muted); padding:3px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background:rgba(0,0,0,.18); white-space:nowrap;}
    .pill{display:inline-flex; align-items:center; gap:6px; padding:3px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background:rgba(0,0,0,.14); font-size:12px; color:var(--muted);}
    .dot{width:8px; height:8px; border-radius:999px; background:var(--muted);}
    canvas{display:block; width:100%; height:auto;}

    .controls{padding:12px; display:flex; flex-direction:column; gap:10px;}
    .ctrl{display:grid; grid-template-columns: 1fr auto; gap:8px 10px; align-items:center; padding:10px; border-radius:12px; background:rgba(0,0,0,.18); border:1px solid rgba(255,255,255,.10);}
    .ctrl label{font-size:12px; color:var(--muted);}
    .ctrl output{font-size:12px; color:var(--ink); opacity:.95;}
    .ctrl input[type="range"]{grid-column:1 / -1; width:100%;}
    .btns{display:flex; gap:8px; flex-wrap:wrap;}
    button{border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.22); color:var(--ink); padding:8px 10px; border-radius:12px; cursor:pointer; font-size:12px;}
    button:hover{border-color:rgba(122,167,255,.55);}

    .eq{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px; line-height:1.45; color:rgba(233,238,252,.95);
      padding:10px 12px 12px; border-top:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.12); white-space:pre-wrap;
    }

    .twoCols{display:grid; grid-template-columns: 1fr 1fr; gap:10px; padding:10px 12px; border-top:1px solid rgba(255,255,255,.10); background:rgba(0,0,0,.10);}
    .box{border:1px solid rgba(255,255,255,.10); background:rgba(0,0,0,.14); border-radius:12px; padding:10px;}
    .box h3{margin:0 0 6px; font-size:12px; color:rgba(233,238,252,.9); font-weight:700;}
    .mini{margin:0; font-size:11px; color:var(--muted); line-height:1.35;}
    .log{margin-top:8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size:11px; color:rgba(233,238,252,.92); line-height:1.35; max-height:170px; overflow:auto;}

    @media (max-width: 980px){ .grid{grid-template-columns: 1fr;} .twoCols{grid-template-columns:1fr;} }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Nilpotent Dirac form (Rowlands-inspired): Local ↔ Nonlocal + Universal Rewrite → Emergent Complexity</h1>
  <p class="sub">
    This is a <b>visual teaching model</b> that mirrors the <b>structure</b> Rowlands emphasizes: a compact Dirac operator/amplitude whose <b>self-product</b> is driven to <b>nilpotency</b> (≈0) when the relativistic balance holds.
    On top: watery / stochastic context; below: a simple operator-level foundation and a miniature “rewrite system” that grows algebraic structure and with it emergent complexity.
  </p>

  <div class="grid">
    <div class="card">
      <div class="hd">
        <div class="row">
          <span class="tag">Top: stochastic / “fluid” emergence</span>
          <span class="pill"><span class="dot" id="nilDot"></span><span id="nilLabel">nilpotency check</span></span>
        </div>
        <span class="tag">Bottom: nilpotent Dirac operator + rewrite trace</span>
      </div>

      <canvas id="fluid" width="1040" height="420"></canvas>
      <canvas id="math" width="1040" height="240"></canvas>

      <div class="twoCols">
        <div class="box">
          <h3>Universal rewrite (toy) — create / conserve</h3>
          <p class="mini">
            We start from a “zero/empty” symbol and repeatedly apply:
            <b>create</b> (introduce a new symbol) and <b>conserve</b> (introduce a dual/conjugate so the total stays balanced).
            The sequence is mapped onto the commonly-cited realization ladder: scalar → pseudoscalar → quaternion → multivariate/vector.
          </p>
          <div class="btns" style="margin-top:8px;">
            <button id="stepBtn">Step rewrite</button>
            <button id="autoBtn">Auto rewrite: off</button>
            <button id="clearBtn">Clear trace</button>
          </div>
          <div class="log" id="rwLog"></div>
        </div>

        <div class="box">
          <h3>Emergence / complexity lens (toy)</h3>
          <p class="mini">
            We measure a simple proxy of “complexity”: <b>interaction richness</b> (local coupling × nonlocal coupling × rewrite depth),
            plus a “bifurcation” score (how often rewrite steps introduce genuinely new operators).
          </p>
          <div class="log" id="cxLog"></div>
        </div>
      </div>

      <div class="eq" id="eqText"></div>
    </div>

    <div class="card">
      <div class="hd">
        <span class="tag">Controls</span>
        <span class="tag" id="modeTag">Mode: balanced (nilpotent)</span>
      </div>

      <div class="controls">
        <div class="ctrl">
          <label for="local">Local coherence ℓ (deterministic / mechanism)</label>
          <output id="localOut"></output>
          <input id="local" type="range" min="0" max="1" step="0.001" value="0.62"/>
        </div>
        <div class="ctrl">
          <label for="nonlocal">Non-local coupling λ (stochastic / long-range)</label>
          <output id="nonlocalOut"></output>
          <input id="nonlocal" type="range" min="0" max="1" step="0.001" value="0.48"/>
        </div>
        <div class="ctrl">
          <label for="m">Mass term m</label>
          <output id="mOut"></output>
          <input id="m" type="range" min="0" max="2" step="0.001" value="0.85"/>
        </div>
        <div class="ctrl">
          <label for="pmag">Momentum magnitude |p|</label>
          <output id="pOut"></output>
          <input id="pmag" type="range" min="0" max="3" step="0.001" value="1.75"/>
        </div>

        <div class="ctrl">
          <label for="breakBalance">Break balance (allow N·N ≠ 0)</label>
          <output id="breakOut"></output>
          <input id="breakBalance" type="range" min="0" max="1" step="1" value="0"/>
          <p class="mini" style="grid-column:1 / -1; margin:0;">
            When off: enforce <code>E² = p² + m²</code> so the nilpotent amplitude squares to ~0.
            When on: let <code>E</code> drift with local/nonlocal forcing so <code>N·N</code> becomes nonzero.
          </p>
        </div>

        <div class="btns">
          <button id="pauseBtn">Pause</button>
          <button id="resetBtn">Reset particles</button>
          <button id="burstBtn">Nonlocal pulse</button>
        </div>

        <p class="mini" style="margin-top:2px;">
          Tip: try λ≈0.7 with balanced mode: you’ll see “watery” turbulence but still constrained by the nilpotent foundation.
          Then switch <b>Break balance</b> on: the whole behavior destabilizes as the constraint lifts.
        </p>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ===== Canvas setup =====
  const fluid = document.getElementById('fluid');
  const math = document.getElementById('math');
  const fctx = fluid.getContext('2d');
  const mctx = math.getContext('2d');

  // ===== UI =====
  const localEl = document.getElementById('local');
  const nonlocalEl = document.getElementById('nonlocal');
  const mEl = document.getElementById('m');
  const pEl = document.getElementById('pmag');
  const breakEl = document.getElementById('breakBalance');

  const localOut = document.getElementById('localOut');
  const nonlocalOut = document.getElementById('nonlocalOut');
  const mOut = document.getElementById('mOut');
  const pOut = document.getElementById('pOut');
  const breakOut = document.getElementById('breakOut');

  const eqText = document.getElementById('eqText');
  const nilDot = document.getElementById('nilDot');
  const nilLabel = document.getElementById('nilLabel');
  const modeTag = document.getElementById('modeTag');

  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const burstBtn = document.getElementById('burstBtn');

  const stepBtn = document.getElementById('stepBtn');
  const autoBtn = document.getElementById('autoBtn');
  const clearBtn = document.getElementById('clearBtn');
  const rwLog = document.getElementById('rwLog');
  const cxLog = document.getElementById('cxLog');

  // ===== Utils =====
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp = (a,b,t)=>a+(b-a)*t;

  function hash2(x,y){
    let n = (x*374761393 + y*668265263) | 0;
    n = (n ^ (n >> 13)) | 0;
    n = (n * 1274126177) | 0;
    return ((n ^ (n >> 16)) >>> 0) / 4294967295;
  }
  function smoothstep(t){ return t*t*(3-2*t); }
  function valueNoise(x,y){
    const xi = Math.floor(x), yi = Math.floor(y);
    const xf = x - xi, yf = y - yi;
    const a = hash2(xi, yi);
    const b = hash2(xi+1, yi);
    const c = hash2(xi, yi+1);
    const d = hash2(xi+1, yi+1);
    const u = smoothstep(xf), v = smoothstep(yf);
    return lerp(lerp(a,b,u), lerp(c,d,u), v);
  }
  function fbm(x,y,oct=4){
    let amp=0.5, sum=0, freq=1;
    for(let i=0;i<oct;i++){
      sum += amp*(valueNoise(x*freq,y*freq)*2-1);
      freq *= 2;
      amp *= 0.5;
    }
    return sum;
  }

  // ===== State =====
  let t = 0;
  let paused = false;

  // Dirac-ish nilpotent amplitude in Rowlands style (visual / toy):
  // ψ = (± i k E ± i (σ·p) + j m) exp(-i(Et - p·r))
  // Nilpotency: ψ^2 = 0 ↔ E^2 - p^2 - m^2 = 0 (in the free case)
  // Here we track the scalar part: N2 = E^2 - (px^2+py^2+m^2).
  let state = {
    local: parseFloat(localEl.value),
    nonlocal: parseFloat(nonlocalEl.value),
    m: parseFloat(mEl.value),
    pMag: parseFloat(pEl.value),
    px: 0, py: 0,
    E: 0,
    breakBalance: parseInt(breakEl.value,10),
    pulse: 0,

    // rewrite
    rwAuto: false,
    rwDepth: 0,
    rwAlphabet: ["0"],
    rwPairs: [],
    rwNewOps: 0,
    rwSteps: 0,
  };

  function updateOutputs(){
    localOut.textContent = state.local.toFixed(3);
    nonlocalOut.textContent = state.nonlocal.toFixed(3);
    mOut.textContent = state.m.toFixed(3);
    pOut.textContent = state.pMag.toFixed(3);
    breakOut.textContent = state.breakBalance ? "on" : "off";
    modeTag.textContent = state.breakBalance ? "Mode: unbalanced (ψ² ≠ 0)" : "Mode: balanced (nilpotent ψ²≈0)";
  }

  // ===== Particles for fluid =====
  const PCOUNT = 1700;
  const particles = new Array(PCOUNT).fill(0).map(()=>({
    x: Math.random()*fluid.width,
    y: Math.random()*fluid.height,
    vx: 0, vy: 0,
    age: Math.random()*200
  }));

  function resetParticles(){
    for(const p of particles){
      p.x = Math.random()*fluid.width;
      p.y = Math.random()*fluid.height;
      p.vx = 0; p.vy = 0;
      p.age = Math.random()*200;
    }
    fctx.clearRect(0,0,fluid.width,fluid.height);
  }

  // ===== Field =====
  function field(x,y,tt){
    const w = fluid.width, h = fluid.height;
    const nx = x / w, ny = y / h;

    // Nonlocal phase: a shared oscillator that correlates distant points
    const phase = tt*0.18 + state.nonlocal*2.0 + state.pulse;

    // Local: coherent “curl-ish” flow from smooth noise
    const s = 2.2 + 2.8*state.local;
    const n1 = fbm(nx*s + Math.cos(phase), ny*s + Math.sin(phase), 4);
    const n2 = fbm(nx*s + 17.3 + Math.sin(phase*0.9), ny*s + 11.7 + Math.cos(phase*1.1), 4);

    let fx = n2;
    let fy = -n1;

    // Nonlocal: inject correlated stochasticity
    const g = 10 + 26*state.nonlocal;
    const jitter = fbm(nx*g + tt*0.35, ny*g - tt*0.31, 3);
    const lam = state.nonlocal;
    fx = (1-lam)*fx + lam*(fx + 0.85*jitter);
    fy = (1-lam)*fy + lam*(fy - 0.85*jitter);

    // Gentle centering
    fx += (0.5 - nx)*0.08;
    fy += (0.5 - ny)*0.08;

    const speed = 1.1 + 2.0*state.local + 2.4*state.nonlocal;
    return {fx: fx*speed, fy: fy*speed};
  }

  // ===== Math panel =====
  function drawMathPanel(N2){
    const W = math.width, H = math.height;
    mctx.clearRect(0,0,W,H);

    // grid bg
    mctx.fillStyle = "rgba(0,0,0,0.12)";
    mctx.fillRect(0,0,W,H);
    mctx.strokeStyle = "rgba(255,255,255,0.08)";
    mctx.lineWidth = 1;
    for(let x=0;x<=W;x+=40){ mctx.beginPath(); mctx.moveTo(x,0); mctx.lineTo(x,H); mctx.stroke(); }
    for(let y=0;y<=H;y+=40){ mctx.beginPath(); mctx.moveTo(0,y); mctx.lineTo(W,y); mctx.stroke(); }

    // Bars for E, px, py, m
    const comps = [
      {name:"E", v:state.E},
      {name:"pₓ", v:state.px},
      {name:"pᵧ", v:state.py},
      {name:"m", v:state.m},
    ];
    const maxAbs = Math.max(0.001, ...comps.map(c=>Math.abs(c.v)));
    const bx0 = 40, by0 = 36;
    const bw = W - 80, bh = H - 110;

    // axis
    mctx.strokeStyle = "rgba(255,255,255,0.22)";
    mctx.beginPath();
    mctx.moveTo(bx0, by0 + bh/2);
    mctx.lineTo(bx0 + bw, by0 + bh/2);
    mctx.stroke();

    const barW = bw / comps.length * 0.62;
    const gap = bw / comps.length;

    comps.forEach((c,i)=>{
      const x = bx0 + gap*i + (gap-barW)/2;
      const mid = by0 + bh/2;
      const h = (Math.abs(c.v)/maxAbs) * (bh*0.42);
      const y = c.v >= 0 ? mid - h : mid;

      // simple palette
      mctx.fillStyle = (c.name === "m") ? "rgba(59,230,176,0.55)" : "rgba(122,167,255,0.55)";
      mctx.fillRect(x, y, barW, h);

      mctx.fillStyle = "rgba(233,238,252,0.92)";
      mctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
      mctx.fillText(c.name, x + 2, by0 + bh + 22);

      mctx.fillStyle = "rgba(169,182,221,0.95)";
      mctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
      mctx.fillText(c.v.toFixed(3), x + 2, by0 + bh + 38);
    });

    // Nilpotency ring
    const absN2 = Math.abs(N2);
    const eps = 0.02;
    const quality = clamp(1 - absN2/eps, 0, 1);

    const cx = W - 90, cy = 70, r = 28;
    mctx.lineWidth = 6;
    mctx.strokeStyle = "rgba(255,255,255,0.18)";
    mctx.beginPath(); mctx.arc(cx,cy,r,0,Math.PI*2); mctx.stroke();

    mctx.strokeStyle = quality > 0.7 ? "rgba(59,230,176,0.8)" : quality > 0.35 ? "rgba(255,204,102,0.85)" : "rgba(255,107,107,0.85)";
    mctx.beginPath();
    mctx.arc(cx,cy,r,-Math.PI/2, -Math.PI/2 + Math.PI*2*quality);
    mctx.stroke();

    mctx.fillStyle = "rgba(233,238,252,0.95)";
    mctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
    mctx.fillText("ψ²", cx-10, cy+5);

    mctx.fillStyle = "rgba(169,182,221,0.95)";
    mctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    mctx.fillText("≈ " + N2.toFixed(4), W - 170, 122);

    // Complexity mini-meter
    const richness = clamp(state.local * state.nonlocal * (1 + state.rwDepth/6), 0, 1);
    const bx = 40, by = H - 56, bw2 = W - 240, bh2 = 12;
    mctx.fillStyle = "rgba(255,255,255,0.10)";
    mctx.fillRect(bx, by, bw2, bh2);
    mctx.fillStyle = "rgba(122,167,255,0.55)";
    mctx.fillRect(bx, by, bw2*richness, bh2);
    mctx.fillStyle = "rgba(169,182,221,0.95)";
    mctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    mctx.fillText("complexity proxy (interaction richness)", bx, by-8);
    mctx.fillText(richness.toFixed(3), bx + bw2 + 10, by + 10);
  }

  function updateEquationText(N2){
    const p2 = state.px*state.px + state.py*state.py;
    const m2 = state.m*state.m;
    const E2 = state.E*state.E;

    const absN2 = Math.abs(N2);
    const eps = 0.02;
    const good = absN2 < eps*0.35;
    const ok = absN2 < eps;

    nilDot.style.background = good ? "rgba(59,230,176,0.9)" : ok ? "rgba(255,204,102,0.9)" : "rgba(255,107,107,0.9)";
    nilLabel.textContent = `|ψ²| = ${absN2.toFixed(4)}`;

    // Rowlands-inspired operator text (kept compact and educational)
    const lines = [];
    lines.push("Rowlands-inspired nilpotent Dirac form (teaching model):");
    lines.push("  ψ = ( ± i k E  ± i (σ·p)  + j m )  · exp( - i (E t − p·r) )");
    lines.push("Nilpotency (free case): ψ² = 0  ⇔  E² − p² − m² = 0");
    lines.push(state.breakBalance ? "(balance broken here → ψ² drifts away from 0)" : "(balanced here → ψ²≈0 enforced via E²=p²+m²)");
    lines.push("");
    lines.push(`Current:  E=${state.E.toFixed(3)}   p=(${state.px.toFixed(3)}, ${state.py.toFixed(3)})   m=${state.m.toFixed(3)}`);
    lines.push(`Squares:  E²=${E2.toFixed(3)}   p²=${p2.toFixed(3)}   m²=${m2.toFixed(3)}   ⇒  ψ²=${N2.toFixed(4)}`);
    lines.push("");
    lines.push("Animation mapping:");
    lines.push("  ℓ (local) → coherent flow (repeatable mechanism)");
    lines.push("  λ (nonlocal) → correlated noise + long-range phase (watery context)");
    lines.push("  Rewrite depth → richer operator ‘alphabet’ → more channels for emergence");

    eqText.textContent = lines.join("\n");
  }

  // ===== Dirac-ish parameter evolution =====
  function updateState(dt){
    state.local = parseFloat(localEl.value);
    state.nonlocal = parseFloat(nonlocalEl.value);
    state.m = parseFloat(mEl.value);
    state.pMag = parseFloat(pEl.value);
    state.breakBalance = parseInt(breakEl.value,10);

    const osc = Math.sin(t*0.35);
    const osc2 = Math.cos(t*0.22);

    const ang = t*0.28 + state.nonlocal*0.9*osc + 0.6*osc2;
    const wob = 0.25*state.nonlocal*Math.sin(t*1.1);

    state.px = state.pMag * Math.cos(ang + wob);
    state.py = state.pMag * Math.sin(ang - wob);

    const p2 = state.px*state.px + state.py*state.py;
    const targetE = Math.sqrt(Math.max(0, p2 + state.m*state.m));

    if(!state.breakBalance){
      state.E = targetE;
    } else {
      const push = 0.25*(state.local - 0.5)*Math.sin(t*0.9) + 0.35*(state.nonlocal - 0.5)*Math.cos(t*0.7);
      state.E = Math.max(0, targetE + push);
    }

    state.pulse *= Math.exp(-dt*1.8);

    if(state.rwAuto){
      // step at a rate that increases with nonlocal coupling
      const rate = 0.35 + 1.2*state.nonlocal;
      state._rwAcc = (state._rwAcc || 0) + dt*rate;
      if(state._rwAcc > 1){
        state._rwAcc = 0;
        stepRewrite();
      }
    }
  }

  // ===== Rewrite system (toy, but faithful to create/conserve feel) =====
  const ladder = [
    {name:"scalar",        add:["1"],                meaning:"mass (as scalar)"},
    {name:"pseudoscalar",  add:["i"],                meaning:"time (imag. scalar)"},
    {name:"quaternion",    add:["j","k"],            meaning:"charge (quaternion units)"},
    {name:"multivector",   add:["e1","e2","e3"],    meaning:"space (vector units)"},
  ];

  function logLine(el, s){
    const div = document.createElement('div');
    div.textContent = s;
    el.appendChild(div);
    el.scrollTop = el.scrollHeight;
  }

  function stepRewrite(){
    const depth = state.rwDepth;
    const step = ladder[Math.min(depth, ladder.length-1)];

    // create: introduce new symbol(s)
    const created = step.add;
    created.forEach(sym => {
      if(!state.rwAlphabet.includes(sym)) state.rwAlphabet.push(sym);
    });

    // conserve: introduce conjugate/dual for each created symbol
    const duals = created.map(s => s + "̄"); // simple notation
    duals.forEach(sym => {
      if(!state.rwAlphabet.includes(sym)) state.rwAlphabet.push(sym);
    });

    // track novelty
    const newOpsNow = created.length;
    state.rwNewOps += newOpsNow;
    state.rwSteps += 1;

    // a “bifurcation” event if we add more than 1 operator at once
    const bif = (created.length > 1) ? "  ↯ bifurcation" : "";

    logLine(rwLog, `step ${state.rwSteps}: create {${created.join(', ')}}; conserve {${duals.join(', ')}}  → realization: ${step.name} (${step.meaning})${bif}`);

    // move up ladder until max
    state.rwDepth = Math.min(state.rwDepth + 1, ladder.length);

    // complexity note
    const richness = clamp(state.local * state.nonlocal * (1 + state.rwDepth/6), 0, 1);
    const bifScore = clamp(state.rwNewOps / Math.max(1,state.rwSteps*3), 0, 1);
    logLine(cxLog, `depth=${state.rwDepth}  alphabet_size=${state.rwAlphabet.length}  richness=${richness.toFixed(3)}  bifurcation=${bifScore.toFixed(3)}`);

    // map deeper rewrite → slightly richer flow
    // (increased shared phase so new “channels” feel like added degrees of freedom)
    state.pulse += 0.25 + 0.15*created.length;
  }

  function clearRewrite(){
    rwLog.innerHTML = "";
    cxLog.innerHTML = "";
    state.rwDepth = 0;
    state.rwSteps = 0;
    state.rwNewOps = 0;
    state.rwAlphabet = ["0"]; // “nothing”
    state.pulse = 0;
  }

  // ===== Main loop =====
  function step(ts){
    if(!step.last) step.last = ts;
    const dt = Math.min(0.05, (ts - step.last)/1000);
    step.last = ts;

    if(!paused){
      t += dt;
      updateState(dt);

      const N2 = state.E*state.E - (state.px*state.px + state.py*state.py + state.m*state.m);

      // Fluid draw w/ trails
      fctx.fillStyle = "rgba(11,16,32,0.10)";
      fctx.fillRect(0,0,fluid.width,fluid.height);

      // vignette
      fctx.save();
      const vg = fctx.createRadialGradient(fluid.width*0.5, fluid.height*0.5, 30, fluid.width*0.5, fluid.height*0.5, fluid.width*0.65);
      vg.addColorStop(0, "rgba(255,255,255,0.03)");
      vg.addColorStop(1, "rgba(0,0,0,0.25)");
      fctx.fillStyle = vg;
      fctx.fillRect(0,0,fluid.width,fluid.height);
      fctx.restore();

      const lam = state.nonlocal;
      const loc = state.local;

      for(const p of particles){
        const F = field(p.x, p.y, t);

        const brown = lam * (fbm(p.x*0.02 + t*1.7, p.y*0.02 - t*1.5, 2)) * 1.6;

        // deeper rewrite slightly increases coupling diversity
        const depthGain = 1 + 0.10*state.rwDepth;

        p.vx = 0.84*p.vx + (0.18*depthGain)*F.fx + brown;
        p.vy = 0.84*p.vy + (0.18*depthGain)*F.fy - brown;

        const damp = lerp(0.82, 0.92, loc);
        p.vx *= damp;
        p.vy *= damp;

        p.x += p.vx;
        p.y += p.vy;
        p.age += 1;

        if(p.x < 0) p.x += fluid.width;
        if(p.x > fluid.width) p.x -= fluid.width;
        if(p.y < 0) p.y += fluid.height;
        if(p.y > fluid.height) p.y -= fluid.height;

        const absN2 = Math.abs(N2);
        const eps = 0.02;
        const quality = clamp(1 - absN2/eps, 0, 1);

        const a = lerp(0.03, 0.11, loc) + lerp(0.02, 0.07, lam);
        fctx.fillStyle = `rgba(122,167,255,${a*lerp(0.65,1.15,quality)})`;

        // droplets when nonlocal dominates
        if(lam > 0.55 && (p.age % 17 === 0)){
          fctx.fillStyle = `rgba(59,230,176,${0.05 + 0.08*lam})`;
          fctx.fillRect(p.x, p.y, 2, 2);
        } else {
          fctx.fillRect(p.x, p.y, 1, 1);
        }

        if(p.age > 450 + 300*Math.random()){
          p.x = Math.random()*fluid.width;
          p.y = Math.random()*fluid.height;
          p.vx = p.vy = 0;
          p.age = 0;
        }
      }

      drawMathPanel(N2);
      updateEquationText(N2);
    }

    requestAnimationFrame(step);
  }

  // ===== Events =====
  function syncFromUI(){
    state.local = parseFloat(localEl.value);
    state.nonlocal = parseFloat(nonlocalEl.value);
    state.m = parseFloat(mEl.value);
    state.pMag = parseFloat(pEl.value);
    state.breakBalance = parseInt(breakEl.value,10);
    updateOutputs();
  }

  [localEl, nonlocalEl, mEl, pEl, breakEl].forEach(el => el.addEventListener('input', syncFromUI));

  pauseBtn.addEventListener('click', () => {
    paused = !paused;
    pauseBtn.textContent = paused ? "Resume" : "Pause";
  });
  resetBtn.addEventListener('click', resetParticles);
  burstBtn.addEventListener('click', () => {
    state.pulse += 2.2;
    for(let i=0;i<particles.length;i+=6){
      particles[i].vx += (Math.random()-0.5)*7;
      particles[i].vy += (Math.random()-0.5)*7;
      particles[i].age = 0;
    }
  });

  stepBtn.addEventListener('click', stepRewrite);
  autoBtn.addEventListener('click', () => {
    state.rwAuto = !state.rwAuto;
    autoBtn.textContent = state.rwAuto ? "Auto rewrite: on" : "Auto rewrite: off";
  });
  clearBtn.addEventListener('click', clearRewrite);

  // ===== Init =====
  resetParticles();
  clearRewrite();
  syncFromUI();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
